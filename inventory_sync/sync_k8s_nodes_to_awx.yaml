---
- name: "E2E | K8s 라벨 → AWX 인벤토리 반영 (kubeconfig 우선 + 상세 로그 + 직접 PATCH + 사후 검증)"
  hosts: localhost
  connection: local
  gather_facts: false
  any_errors_fatal: true

  vars:
    controller_host: "http://awx-service.awx.svc.cluster.local"
    controller_oauthtoken: ""
    organization_name: "Default"
    inventory_name: "k3s-nodes"

    # 폴백용(크레덴셜이 없을 때만 사용)
    k8s_host: "https://kubernetes.default.svc"
    k8s_token: ""
    k8s_validate_certs: false

    awx_node_user: "ubuntu"

  tasks:
    # 0) AWX ping
    - name: "[0] Preflight | GET /api/v2/ping"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/ping/"
        method: GET
        headers: { Authorization: "Bearer {{ controller_oauthtoken }}" }
        return_content: true
        status_code: 200
        validate_certs: false
      register: awx_ping

    - name: "[0] Ping 결과 요약"
      ansible.builtin.debug:
        msg:
          - "AWX version={{ awx_ping.json.version | default('unknown') }}"
          - "active_node={{ awx_ping.json.active_node | default('n/a') }}"

    # 1) 조직/인벤토리 보장
    - name: "[1] 조직 조회 (name={{ organization_name }})"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/organizations/?name={{ organization_name | urlencode }}"
        method: GET
        headers: { Authorization: "Bearer {{ controller_oauthtoken }}" }
        return_content: true
        status_code: 200
        validate_certs: false
      register: org_q

    - name: "[1] 조직 존재 확인"
      ansible.builtin.assert:
        that: "(org_q.json.results | length) > 0"
        fail_msg: "조직 '{{ organization_name }}' 을(를) 찾지 못했습니다."

    - name: "[1] organization_id 설정"
      ansible.builtin.set_fact:
        organization_id: "{{ org_q.json.results[0].id | int }}"

    - name: "[1] 인벤토리 보장 (POST-if-needed)"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/inventories/"
        method: POST
        headers:
          Authorization: "Bearer {{ controller_oauthtoken }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "{{ inventory_name }}"
          organization: "{{ organization_id }}"
        status_code: [201, 400]
        validate_certs: false
      register: inv_post
      failed_when: inv_post.status not in [201, 400]

    - name: "[1] 인벤토리 ID 확보 (GET)"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/inventories/?name={{ inventory_name | urlencode }}&organization={{ organization_id }}"
        method: GET
        headers: { Authorization: "Bearer {{ controller_oauthtoken }}" }
        return_content: true
        status_code: 200
        validate_certs: false
      register: inv_get

    - name: "[1] 인벤토리 존재 확인"
      ansible.builtin.assert:
        that: "(inv_get.json.results | length) > 0"
        fail_msg: "인벤토리 '{{ inventory_name }}' 을(를) 찾지 못했습니다."

    - name: "[1] inventory_id 설정 + 요약"
      ansible.builtin.set_fact:
        inventory_id: "{{ inv_get.json.results[0].id | int }}"
    - name: "[1] 요약"
      ansible.builtin.debug:
        msg:
          - "organization_id={{ organization_id }}"
          - "inventory_id={{ inventory_id }} ({{ inventory_name }})"

    # 2) K8s 인증 인자 합성 (kubeconfig 우선)
    - name: "[2] kubeconfig 주입 여부 점검"
      ansible.builtin.set_fact:
        injected_kubeconfig: "{{ lookup('env','K8S_AUTH_KUBECONFIG') | default('', true) }}"
    - name: "[2] k8s_info 인자 합성 (kubeconfig 우선, 없으면 host+token 폴백)"
      ansible.builtin.set_fact:
        k8s_info_args: >-
          {{
            (
              {'api_version':'v1','kind':'Node'} |
              combine(
                (injected_kubeconfig | length > 0)
                | ternary(
                  {'kubeconfig': injected_kubeconfig},
                  {'host': k8s_host, 'api_key': k8s_token, 'validate_certs': k8s_validate_certs}
                )
              )
            )
          }}

    - name: "[2] k8s_info 인자 디버그"
      ansible.builtin.debug:
        var: k8s_info_args

    # 2) K8s 노드 수집
    - name: "[2] K8s Nodes 수집(k8s_info)"
      kubernetes.core.k8s_info: "{{ k8s_info_args }}"
      register: k8s_nodes

    - name: "[2] nodes_flat 구성(name, ip, labels)"
      ansible.builtin.set_fact:
        nodes_flat: []
    - ansible.builtin.set_fact:
        nodes_flat: >-
          {{ nodes_flat + [ {
              'name': item.metadata.name,
              'ip': (
                (item.status.addresses | default([]))
                | selectattr('type','equalto','InternalIP')
                | map(attribute='address') | list | first | default('')
              ),
              'labels': (item.metadata.labels | default({}))
            } ] }}
      loop: "{{ k8s_nodes.resources | default([]) }}"
      loop_control: { label: "{{ (item.metadata.name | default('unknown')) }}" }

    - name: "[2] 발견한 노드 목록 (name/ip/labels)"
      ansible.builtin.debug:
        var: nodes_flat

    - name: "[2] 노드 수집 검증"
      ansible.builtin.assert:
        that: "(nodes_flat | length) > 0"
        fail_msg: "K8s에서 노드를 하나도 찾지 못했습니다."

    # 3) 호스트 존재 확인 → 생성
    - name: "[3] 1/5 호스트 조회 (name+inventory)"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/hosts/?name={{ item.name | urlencode }}&inventory={{ inventory_id }}"
        method: GET
        headers: { Authorization: "Bearer {{ controller_oauthtoken }}" }
        return_content: true
        status_code: 200
        validate_certs: false
      loop: "{{ nodes_flat }}"
      loop_control: { label: "{{ item.name }}" }
      register: host_query1

    - name: "[3] 조회 결과 병합(존재 여부/ID)"
      ansible.builtin.set_fact:
        host_records: "{{ (host_records | default([])) + [ {
                          'name': item.0.name,
                          'ip': item.0.ip,
                          'labels': item.0.labels,
                          'exists': ((item.1.json.results | length) > 0),
                          'host_id': (item.1.json.results[0].id if (item.1.json.results | length) > 0 else None)
                        } ] }}"
      loop: "{{ nodes_flat | zip(host_query1.results) | list }}"

    - name: "[3] 2/5 없는 호스트 생성(POST)"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/hosts/"
        method: POST
        headers:
          Authorization: "Bearer {{ controller_oauthtoken }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "{{ item.name }}"
          inventory: "{{ inventory_id }}"
          enabled: true
        status_code: [201, 400]
        validate_certs: false
      when: not item.exists
      loop: "{{ host_records }}"
      loop_control: { label: "{{ item.name }}" }
      register: host_create

    - name: "[3] 3/5 생성 이후 ID 재조회(GET)"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/hosts/?name={{ item.name | urlencode }}&inventory={{ inventory_id }}"
        method: GET
        headers: { Authorization: "Bearer {{ controller_oauthtoken }}" }
        return_content: true
        status_code: 200
        validate_certs: false
      loop: "{{ nodes_flat }}"
      loop_control: { label: "{{ item.name }}" }
      register: host_query2

    - name: "[3] 4/5 host_id 확정 리스트 재구성"
      ansible.builtin.set_fact:
        host_records2: "{{ (host_records2 | default([])) + [ {
                           'name': item.0.name,
                           'ip': item.0.ip,
                           'labels': item.0.labels,
                           'host_id': (item.1.json.results[0].id if (item.1.json.results | length) > 0 else None)
                         } ] }}"
      loop: "{{ nodes_flat | zip(host_query2.results) | list }}"

    - name: "[3] 5/5 host_id 미확보 검증"
      ansible.builtin.assert:
        that: "item.host_id is not none"
        fail_msg: "host_id 확보 실패: {{ item.name }}"
      loop: "{{ host_records2 }}"
      loop_control: { label: "{{ item.name }}" }

    # 4) 현재 variables GET → 목표와 비교 → 필요 시 PATCH
    - name: "[4] 1/4 현재 variables 조회(GET /hosts/<id>/)"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/hosts/{{ item.host_id }}/"
        method: GET
        headers: { Authorization: "Bearer {{ controller_oauthtoken }}" }
        return_content: true
        status_code: 200
        validate_certs: false
      loop: "{{ host_records2 }}"
      loop_control: { label: "{{ item.name }}" }
      register: host_detail

    - name: "[4] 2/4 비교·목표 YAML 생성"
      ansible.builtin.set_fact:
        desired_map: >-
          {{
            (desired_map | default({})) | combine({
              item.0.name: {
                'desired_yaml': ({
                    'ansible_host': item.0.ip,
                    'ansible_user': awx_node_user,
                    'k8s_name':     item.0.name,
                    'k8s_labels':   item.0.labels|default({})
                 } | to_nice_yaml | trim),
                'current_yaml': ((item.1.json.variables | default('')) | trim),
                'host_id': item.0.host_id
              }
            })
          }}
      loop: "{{ host_records2 | zip(host_detail.results) | list }}"

    - name: "[4] 3/4 변경 필요한 대상 목록 산출"
      ansible.builtin.set_fact:
        to_patch: >-
          {{
            desired_map
            | dict2items
            | selectattr('value.desired_yaml', 'ne', 'value.current_yaml')
            | map(attribute='value')
            | list
          }}

    - name: "[4] 변경 대상 요약(개수={{ to_patch|length }})"
      ansible.builtin.debug:
        var: to_patch

    - name: "[4] 4/4 PATCH /hosts/<id>/ (variables 갱신)"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/hosts/{{ item.host_id }}/"
        method: PATCH
        headers:
          Authorization: "Bearer {{ controller_oauthtoken }}"
          Content-Type: "application/json"
        body_format: json
        body:
          variables: "{{ item.desired_yaml }}"
        return_content: true
        status_code: 200
        validate_certs: false
      loop: "{{ to_patch }}"
      loop_control: { label: "{{ item.host_id }}" }
      register: patch_results
      when: to_patch | length > 0

    # 5) 사후 검증
    - name: "[5] 사후 검증 | hosts/?inventory=<id>"
      ansible.builtin.uri:
        url: "{{ controller_host | regex_replace('/$','') }}/api/v2/hosts/?inventory={{ inventory_id }}"
        method: GET
        headers: { Authorization: "Bearer {{ controller_oauthtoken }}" }
        return_content: true
        status_code: 200
        validate_certs: false
      register: final_hosts

    - name: "[5] 최종 리포트(호스트별 variables 스니펫)"
      ansible.builtin.debug:
        msg: >-
          {{
            final_hosts.json.results
            | map('extract', {'name': 'name', 'variables': 'variables'})
            | list
          }}
